/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "observer.h"
#include "Ifx_Types.h"
#include "commonMacros.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define J   2.09E-5
#define B   0.00002
#define Kt  0.042
#define Kb  0.042
#define R   8.4
#define L   1.16

#define L1  891.8017
#define L2  262510
#define L3  12439

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
float64 g_theta_h[2] = {0.0, 0.0};
float64 g_w_h[2] = {0.0, 0.0};
float64 g_i_h[2] = {0.0, 0.0};

float64 g_int_theta_h[2] = {0.0, 0.0};
float64 g_int_w_h[2] = {0.0, 0.0};
float64 g_int_i_h[2] = {0.0, 0.0};

float64 theta_tilde;
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void observeMotor(uint8 chn, float64 v_in, float64 theta)
{
    theta_tilde = theta - g_theta_h[chn];

    g_int_theta_h[chn] += (g_w_h[chn] + (theta_tilde * L1)) * 0.001;
    g_theta_h[chn] = g_int_theta_h[chn];

    g_int_w_h[chn] += ((Kt / J * g_i_h[chn]) + (-B / J * g_w_h[chn]) + (theta_tilde * L2)) * 0.001;
    g_w_h[chn] = g_int_w_h[chn];

    g_int_i_h[chn] += ((-R / L * g_i_h[chn]) + (-Kb / L * g_w_h[chn]) + (v_in / L) + (theta_tilde * L3)) * 0.001;
    g_i_h[chn] = g_int_i_h[chn];
}

float64 getThetaHat(uint8 chn)
{
    return g_theta_h[chn];
}

float64 getWHat(uint8 chn)
{
    return g_w_h[chn];
}

float64 getIHat(uint8 chn)
{
    return g_i_h[chn];
}
